---
editor_options: 
  markdown: 
    wrap: 72
---

# Overview

Phenology is the timing of life history events. Important phenological
events for plants involve the growth of leaves, flowering, and
senescence (death of leaves). Plants species adapt the timing of these
events to local climate conditions to ensure successful reproduction.
Subsequently, animal species often adapt their phenology to take
advantage of food availability. As the climate shifts this
synchronization is being thrown out of whack. Shifts in phenology are
therefore a common yardstick of understanding how and if ecosystems are
adjusting to climate change.

Plant species may employ the following phenological strategies:

-   winter deciduous: lose leaves in the winter, grow new leaves in the
    spring
-   drought deciduous: lose leaves in the summer when water is limited
-   evergreen: maintain leaves year-round

credit: this lab is based on a materials developed by Chris Kibler.

# Task

In this lab we are analyzing plant phenology near the Santa Clara River
which flows from Santa Clarita to Ventura. We will investigate the
phenology of the following plant communities:

-   riparian forests: grow along the river, dominated by winter
    deciduous cottonwood and willow trees
-   grasslands: grow in openspaces, dominated by drought deciduous
    grasses
-   chaparral shrublands: grow in more arid habitats, dominated by
    evergreen shrubs

To investigate the phenology of these plant communities we will a time
series of Landsat imagery and polygons identifying the locations of
study sites within each plant community.\

## Applying the "Environmental Data Science Problem" Workflow

**Data**

-   monthly satellite data
-   Information on location of vegetation communities

**Tools**

-   raster and vector tools

**Inputs**

-   monthly satellite reflectance data
-   polygons of study sites for each veg community

**Outputs**

-   time series of NDVI for each veg community

## Data

**Landsat Operational Land Imager (OLI sensor)**

-   8 pre-processed scenes
    -   Level 2 surface reflectance products
    -   erroneous values were set to NA
    -   scale factor set to 100
    -   bands 2-7
    -   dates in filenname
-   a \

**Study sites**

-   polygons representing sites
    -   study_site: character string with plant type
-   a

## Summary of approach

-   Convert spectral relfectance into a measure of vegetation
    productivity (NDVI)
-   Calulate NDVI throughout the year
-   Summarize NDVI values within vegetation communities
-   Visualize changes in NDVI within vegetation communities

# Workflow

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, include = TRUE)
```

```{r include=TRUE, message=FALSE}
library(terra)
library(sf)
library(dplyr)
library(tidyr)
library(stringr)
library(ggplot2)
library(here)
library(tmap)
library(cowplot) #adds aesthetics for working w ggplot

rm(list = ls())
here::i_am("w8-lab-template.Rmd")
```

### Create NDVI function

Let's start by defining a function to compute the Normalized Difference
Vegetation Index (NDVI). NDVI computes the difference in reflectance in
the near infrared and red bands, normalized by their sum.

```{r ndvi-function}
ndvi_fun <- function(nir, red) {
  (nir - red)/(nir + red)
}
```

### Computing NDVI for a single scene

We have 8 scenes collected by the Landsat OLI sensor on 8 different days
throughout the year. Let's start by loading in the first scene collected
on June 12, 2018

```{r}
# load in data from June 12, 2018
landsat_20180616 <- rast(here('data','landsat_20180612.tif'))

# view raster data
landsat_20180616
```

Now let's update the **names** of the layers to match the spectral bands
they correspond to

```{r}
# update names (would find this info in documentation)
names(landsat_20180616) <- c('blue', 'green', 'red', 'NIR', 'SWIR1', 'SWIR2')

# view updated names
landsat_20180616
```

Now we can apply the NDVI function we created to compute NDVI for this
scene using the `lapp()` function. The `lapp()` function applies a
function to each cell using layers as arguments. Therefore, we need to
tell `lapp()` which layers (or bands) to pass into the function. The NIR
band is the 4th layer and the red band is the 3rd layer in our raster.
In this case, because we defined the NIR band as the first argument and
the red band as the second argument in our function, we tell `lapp()` to
use the 4th layer (NIR) first and 3rd (Red) layer second.

```{r}
# calculate ndvi for 
ndvi_20180612 <- lapp(landsat_20180616[[c(4,3)]], fun = ndvi_fun)

# print, values will be between -1 and 1
ndvi_20180612

# plot to view
plot(ndvi_20180612)
```

### Computing NDVI for all scenes - attempt 2

The first attempt was pretty clunky and required a lot of copy/pasting.
Because we're performing the same operations over and over again, this
is a good opportunity to generalize our workflow into a function!

#### Starting from scratch

Let's start over and see how we could do this more efficiently. We'll
clear our environment and redefine our function for NDVI.

```{r}
rm(list = ls())
here::i_am("w8-lab-template.Rmd")

ndvi_fun = function(nir, red){
  (nir - red) / (nir + red)
}
```

#### Outlining our function

Let's first sketch out what operations we want to perform so we can
figure out what our function needs.

```{r eval=FALSE}
# create pseudocode for the process of reading in data, renaming, and ndvi
landsat <- rast(file) #read in files
names(landsat) <- c('blue', 'green', 'red', 'NIR', 'SWIR1', 'SWIR2') #rename bands
ndvi <- lapp(landsat[[c(4,3)]], fun = ndvi_fun)

# Pass the steps outlined above into a function
create_ndvi_layer <- function(file){
  landsat <- rast(file) 
  names(landsat) <- c('blue', 'green', 'red', 'NIR', 'SWIR1', 'SWIR2')
  ndvi <- lapp(landsat[[c(4,3)]], fun = ndvi_fun)
  return(ndvi)
}

# note: this code is not meant to run! we're just outlining the function we want to create
```

#### Creating a list of files/scenes

We want a list of the scenes so that we can tell our function to compute
NDVI for each. To do that we look in our data folder for the relevant
file.

```{r}
# here we're asking for the names of all the files in the week8 folder
# the "pattern" option returns names that end in .tif (the file extension for the landsat scences)
# the "full.names" option returns the full file path for each scene

# list all .tif files w/in data folder of W8
files <- list.files(here('data'), pattern = '*.tif', full.names = TRUE)
```

#### updating our function

Now let's update our function to work with list of file names we created

```{r}
# now we're passing our function a number that will correspond to the index in the list of file names
create_ndvi_layer <- function(i){
  landsat <- rast(files[i]) 
  names(landsat) <- c('blue', 'green', 'red', 'NIR', 'SWIR1', 'SWIR2')
  ndvi <- lapp(landsat[[c(4,3)]], fun = ndvi_fun)
  return(ndvi)
}

# let's test our function by asking it to read in the first file 
test <- create_ndvi_layer(1)
plot(test) #this is the same as the first plot above
```

#### Run function on all scenes!

Now we can use our function to create a NDVI layer for each scene and
stack them into a single rasterstack.

```{r}
# create NDVI layer for each scene (day) and stack into a single rasterstack
all_ndvi <- c(create_ndvi_layer(1), #use c to create raster stack
              create_ndvi_layer(2),
              create_ndvi_layer(3),
              create_ndvi_layer(4),
              create_ndvi_layer(5),
              create_ndvi_layer(6),
              create_ndvi_layer(7),
              create_ndvi_layer(8)) 
all_ndvi
# update layer names to match date
names(all_ndvi) <- c("2018-06-12",
                     "2018-08-15",
                     "2018-10-18",
                     "2018-11-03",
                     "2019,01-22",
                     "2019-02-23",
                     "2019-04-07",
                     "2019-07-01")
all_ndvi
```

### Compare NDVI across vegetation communities

Now that we have computed NDVI for each of our scenes (days) we want to
compare changes in NDVI values across different vegetation communities.

#### read in study sites

First, we'll read in a shapefile of study sites.

```{r include=TRUE}
#vector data, read in shape file using st_read from sf package
  #all files are read in when you use shp
sites <- st_read(here('data','study_sites.shp'))

# plot study sites on a single NDVI layer
tm_shape(all_ndvi[[1]]) + #select only first data
  tm_raster() +
  tm_shape(sites) +
  tm_polygons() #plot site shapes as polygons
```

#### Extract NDVI at study sites

Here we find the average NDVI within each study site. The output of
extract is a data frame with rows that match the study site dataset, so
we bind the results to the original dataset.

```{r include=TRUE}
sites_ndvi <- terra::extract(all_ndvi, sites, fun = "mean")#avg NDVI from each site + layer

#can column bind instead of join since it's the same order
sites_annotated <- cbind(sites, sites_ndvi)

# View
View(sites_annotated)
```

#### Clean results

We're done! Except our data is very untidy... Let's tidy it up!\

-   convert to data frame
-   turn from wide to long format
-   turn layer names into date format

```{r include=TRUE}
sites_clean <- sites_annotated %>% 
  st_drop_geometry() %>% #don't need geoms anymore
  select(-ID) %>% #ID was created by terra, but not needed
  pivot_longer(!study_site) %>%  #changes to rows instead of columns
  mutate('year' = str_sub(name, 2, 5), #pulls chrs 2-5
         'month' = str_sub(name, 7, 8), #pulls chrs 7-8
         'day' = str_sub(name, -2, -1)) %>% #negative to pull backwards
  unite("date", 4:6, sep = "-") %>% #combing date col, use hyphen to separate
  mutate("date" = lubridate::as_date(date)) %>% 
  select(-name) #remove name col generated by pivot

View(sites_clean)
```

#### Plot results

```{r include=TRUE}
ggplot(sites_clean,
       aes(x = date, y = value, 
           group = study_site, col = study_site)) + #group and color by site
  geom_line() +
  theme_minimal() +
  labs(x='Date', y='NDVI',
       color = 'Site Type',
       title = 'Phenology of NDVI')
```
